### 迭代器（Iterator）

**定义**：  
迭代器是一个对象，它实现了迭代器协议，即包含 `__iter__()` 和 `__next__()` 方法。`__iter__()` 方法返回迭代器对象本身，而 `__next__()` 方法返回序列中的下一个元素。当没有更多元素时，`__next__()` 会抛出 `StopIteration` 异常。

**特点**：

1. ​**惰性计算**：迭代器不会一次性生成所有元素，而是在需要时才生成下一个元素。
2. ​**只能向前**：迭代器只能向前移动，不能后退或重新开始。

**应用场景**：

1. ​**遍历集合**：如列表、元组、字典等。
2. ​**处理大数据集**：由于迭代器是惰性计算的，适合处理大数据集，避免一次性加载所有数据到内存中。

**生活例子**：  
假设你有一个装满糖果的罐子，你每次只能从罐子里拿出一颗糖果。你每次拿糖果的动作就相当于调用 `__next__()` 方法，而罐子本身就是一个迭代器。当你拿完所有糖果后，罐子就空了，相当于抛出 `StopIteration` 异常。

### 生成器（Generator）

**定义**：  
生成器是一种特殊的迭代器，它使用 `yield` 关键字来生成值。生成器函数在每次调用 `__next__()` 时执行，直到遇到 `yield` 语句，返回 `yield` 后面的值，并暂停执行。下次调用 `__next__()` 时，生成器从上次暂停的地方继续执行。

**特点**：

1. ​**简洁**：生成器函数的代码比手动实现迭代器更简洁。
2. ​**状态保存**：生成器函数在每次 `yield` 时保存当前状态，下次调用时从该状态继续执行。

**应用场景**：

1. ​**生成无限序列**：如斐波那契数列、素数序列等。
2. ​**处理流式数据**：如读取大文件、处理网络数据流等。

**生活例子**：  
假设你有一个自动售货机，每次按下按钮，它就会吐出一包薯片。这个自动售货机就是一个生成器，每次按下按钮相当于调用 `__next__()` 方法，而 `yield` 语句就是吐出薯片的动作。自动售货机内部的状态（如剩余的薯片数量）在每次吐出薯片后都会被保存，直到薯片卖完为止。

### 实际例子

**迭代器例子**：

python

```python
class CountDown:
    def __init__(self, start):
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        else:
            self.current -= 1
            return self.current + 1

# 使用迭代器
countdown = CountDown(5)
for number in countdown:
    print(number)
```

这个例子中，`CountDown` 类实现了一个倒计时的迭代器，每次调用 `__next__()` 方法时，返回当前计数值并减一，直到计数值为0。

**生成器例子**：

python

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# 使用生成器
fib = fibonacci()
for _ in range(10):
    print(next(fib))
```

这个例子中，`fibonacci` 函数是一个生成器，它生成斐波那契数列。每次调用 `next(fib)` 时，生成器会返回下一个斐波那契数，并暂停执行，直到下次调用 `next(fib)`。

### 总结

- ​**迭代器**​ 是一个实现了 `__iter__()` 和 `__next__()` 方法的对象，用于遍历集合或生成序列。
- ​**生成器**​ 是一种特殊的迭代器，使用 `yield` 关键字来生成值，代码更简洁且能保存状态。

两者都适用于处理大数据集或生成无限序列的场景，生成器由于其简洁性和状态保存能力，在实际应用中更为常见。
